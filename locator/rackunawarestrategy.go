// Copyright (c) 2020 DistAlchemist
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

package locator

import (
	"sort"

	"github.com/DistAlchemist/Mongongo/config"
	"github.com/DistAlchemist/Mongongo/network"
)

// RackUnawareStrategy implements rackstrategy interface
type RackUnawareStrategy struct {
	//
	// *RackStrategy
	tokenMetadata TokenMetadata
}

// GetStorageEndPoints return tokens generated by consistent hashing
// input is a list of rowKeys
func (rus *RackUnawareStrategy) GetStorageEndPoints(token string) []network.EndPoint {
	return rus.getStorageEndPoints(token, rus.GetTokenEndPointMap())
}

// GetTokenEndPointMap returns a copy of tokenEndPointMap from
// tokenMetadata
func (rus *RackUnawareStrategy) GetTokenEndPointMap() map[string]network.EndPoint {
	return rus.tokenMetadata.CloneTokenEndPointMap()
}

// GetToken returns endpoint's token through tokenMetadata
func (rus *RackUnawareStrategy) GetToken(endPoint network.EndPoint) string {
	return rus.tokenMetadata.GetToken(endPoint)
}

func contains(list []network.EndPoint, key network.EndPoint) bool {
	for _, tmp := range list {
		if tmp == key {
			return true
		}
	}
	return false
}

func (rus *RackUnawareStrategy) getStorageEndPoints(token string, tokenEndPointMap map[string]network.EndPoint) []network.EndPoint {
	list := make([]network.EndPoint, 0)
	foundCnt := 0
	N := config.ReplicationFactor
	tokens := make([]string, 0, len(tokenEndPointMap))
	for k := range tokenEndPointMap {
		tokens = append(tokens, k)
	}
	sort.Strings(tokens)
	// The return value is the index to insert of not present.
	idx := sort.SearchStrings(tokens, token)
	totalNodes := len(tokens)
	if idx == totalNodes {
		idx = 0
	}
	// add the node at index
	list = append(list, tokenEndPointMap[tokens[idx]])
	foundCnt++
	startIdx := (idx + 1) % totalNodes
	for i, count := startIdx, 1; count < totalNodes && foundCnt < N; count, i = count+1, (i+1)%totalNodes {
		endPoint := tokenEndPointMap[tokens[i]]
		if contains(list, endPoint) == false {
			list = append(list, endPoint)
			foundCnt++
		}
	}
	retrofitPorts(list)
	return list
}

// GetReadStorageEndPoints ...
func (rus *RackUnawareStrategy) GetReadStorageEndPoints(token string) map[network.EndPoint]bool {
	return rus.GetReadStorageEndPointsM(token, rus.tokenMetadata.tokenToEndPointMap)
}

// GetReadStorageEndPointsM ...
func (rus *RackUnawareStrategy) GetReadStorageEndPointsM(token string, tokenToEndPointMap map[string]network.EndPoint) map[network.EndPoint]bool {
	tokenList := rus.getStorageTokens(token, tokenToEndPointMap, nil)
	list := make([]network.EndPoint, 0)
	for _, t := range tokenList {
		list = append(list, tokenToEndPointMap[t])
	}
	retrofitPorts(list)
	res := make(map[network.EndPoint]bool)
	for _, l := range list {
		res[l] = true
	}
	return res
}

func (rus *RackUnawareStrategy) getStorageTokens(token string, tokenToEndPointMap map[string]network.EndPoint,
	bootStrapTokenToEndPointMap map[string]network.EndPoint) []string {
	var startIndex int
	tokenList := make([]string, 0)
	foundCnt := 0
	tokens := make([]string, 0)
	for t := range tokenToEndPointMap {
		tokens = append(tokens, t)
	}
	var bsTokens []string
	if bootStrapTokenToEndPointMap != nil {
		bsTokens = make([]string, 0)
		for t := range bootStrapTokenToEndPointMap {
			tokens = append(tokens, t)
		}
	}
	sort.Strings(tokens)
	index := sort.SearchStrings(tokens, token)
	totalNodes := len(tokens)
	// add the token at the index by default
	tokenList = append(tokenList, tokens[index])
	if bsTokens == nil || containS(bsTokens, tokens[index]) == false {
		foundCnt++
	}
	startIndex = (index + 1) % totalNodes
	// if we found N number of nodes we are good. this loop
	// will just exit. otherwise just loop through the list
	// and add until we have N nodes
	for i, count := startIndex, 1; count < totalNodes && foundCnt < config.ReplicationFactor; count, i = count+1, (i+1)%totalNodes {
		if containS(tokenList, tokens[i]) == false {
			tokenList = append(tokenList, tokens[i])
			// don't count bootstrapping tokens towards the count
			if bsTokens == nil || containS(bsTokens, tokens[i]) == false {
				foundCnt++
			}
		}
	}
	return tokenList
}

func containS(list []string, elem string) bool {
	for _, e := range list {
		if e == elem {
			return true
		}
	}
	return false
}
