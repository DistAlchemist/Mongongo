// Copyright (c) 2020 DistAlchemist
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

package locator

import (
	"sort"

	"github.com/DistAlchemist/Mongongo/config"
	"github.com/DistAlchemist/Mongongo/network"
)

// RackUnawareStrategy implements rackstrategy interface
type RackUnawareStrategy struct {
	//
	// *RackStrategy
	tokenMetadata TokenMetadata
}

// GetStorageEndPoints return tokens generated by consistent hashing
// input is a list of rowKeys
func (rus *RackUnawareStrategy) GetStorageEndPoints(token string) []network.EndPoint {
	return rus.getStorageEndPoints(token, rus.GetTokenEndPointMap())
}

// GetTokenEndPointMap returns a copy of tokenEndPointMap from
// tokenMetadata
func (rus *RackUnawareStrategy) GetTokenEndPointMap() map[string]network.EndPoint {
	return rus.tokenMetadata.CloneTokenEndPointMap()
}

// GetToken returns endpoint's token through tokenMetadata
func (rus *RackUnawareStrategy) GetToken(endPoint network.EndPoint) string {
	return rus.tokenMetadata.GetToken(endPoint)
}

func contains(list []network.EndPoint, key network.EndPoint) bool {
	for _, tmp := range list {
		if tmp == key {
			return true
		}
	}
	return false
}

func (rus *RackUnawareStrategy) getStorageEndPoints(token string, tokenEndPointMap map[string]network.EndPoint) []network.EndPoint {
	list := make([]network.EndPoint, 0)
	foundCnt := 0
	N := config.ReplicationFactor
	tokens := make([]string, 0, len(tokenEndPointMap))
	for k := range tokenEndPointMap {
		tokens = append(tokens, k)
	}
	sort.Strings(tokens)
	// The return value is the index to insert of not present.
	idx := sort.SearchStrings(tokens, token)
	totalNodes := len(tokens)
	if idx == totalNodes {
		idx = 0
	}
	// add the node at index
	list = append(list, tokenEndPointMap[tokens[idx]])
	foundCnt++
	startIdx := (idx + 1) % totalNodes
	for i, count := startIdx, 1; count < totalNodes && foundCnt < N; count, i = count+1, (i+1)%totalNodes {
		endPoint := tokenEndPointMap[tokens[i]]
		if contains(list, endPoint) == false {
			list = append(list, endPoint)
			foundCnt++
		}
	}
	retrofitPorts(list)
	return list
}
